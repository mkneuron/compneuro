function [w,theta,F] = boltzMann(I,noise)

if nargin < 2
    noise = 0.2;
end
if nargin < 1
    I = 0;
end
%% preprocessing
rand('seed',0);
load('mnistAll.mat');

X=mnist.train_images;
X=2*double(min(X,1))-1;
X=X.*(1-2*(rand(size(X))<noise));
y=mnist.train_labels;

XI=X(:,:,find(y==I));
% vectorize patterns
XI = reshape(XI,28*28,size(XI,3));

D=28*28;

%% init vars

w=zeros(D,D);
theta=zeros(D,1);
P = size(XI,2); % number of patterns

%% calculate clamped statistics <si>_c, <sisj>_c
% E(si)_c = 1/p sum over patterns
e_si_c = (1/P)*sum(XI,2); % 

%% translate to mean field equations
mi = e_si_c; % <si>c
e_sisj_c = (1/P)*(XI*XI'); %<sisj>_c = correlation sum over patterns
% mimj = mi*mj exept when i=j, then it's 1.
mimj = (mi*mi');%.* (ones(size(mi,1))-eye(size(mi,1)));

%% calculate mean field equations
% C = <sisj>_c - <si>_c*<sj>_c  
Chi  = (e_sisj_c) - mimj.* (ones(size(mi,1))-eye(size(mi,1))); %
Chi_ii = eye(size(mi,1))-diag(mi.^2,0);
Chi = Chi+Chi_ii;
invC = inv(Chi).* (ones(size(mi,1))-eye(size(mi,1)));

% calculate wij = d_ij/(1-mi) -invC

% one_minus_mi_sq = 1 - (mi .^2); % calculate 1-mi^2
% mi_matrix_form = ones(size(mi))*one_minus_mi_sq'; % make it into matrix form
w = inv(Chi_ii) - invC;

% % new theta
theta = atanh(mi)-(w*mi);

%compute mean field approximation for Z
F = -1/2*sum(sum(w.*mimj)) ...
    -theta'*mi ...
    +1/2*(1+mi')*log(1/2*(1+mi))+(1-mi')*log(1/2*(1-mi));
end
